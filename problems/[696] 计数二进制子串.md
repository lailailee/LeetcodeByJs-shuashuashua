
## [696] 计数二进制子串( Count Binary Substrings)

- 类型：字符串类

- 难度: 简单

#### 题目描述:

给定一个字符串s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。


#### 示例:

**示例一:**

输入: "00110011"

输出: 6

解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。

**示例二:**

输入: "10101"

输出: 4

解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。

#### 思路

- 观察得：每进一位最多只会有一个子串
- current当前字符个数，默认为1，preview前一个字符个数，默认为0
- 如果当前字符与下一个字符相等，则current+1
- 如果当前字符与下一个字符不等，则把当前字符个数赋给前一个字符的个数，再将当前字符个数清为1
- 判断是否含有子串则是比较前一个字符个数大于等于当前字符个数,符合条件则肯定有一个子串，结合观察给与进位继续循环 (preview >= current) n++


#### 表格示意

输入: "00110011"

输出: 6


| \   | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |   
| -   | - | - | - | - | - | - | - | - |
| pre | 0 | 0 | 2 | 2 | 2 | 2 | 2  |2 |
| cur | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 |
| n   | 0 | 0 | 1 | 2 | 3 | 4 | 5 | 6 |

输入: "10101"

输出: 4

| \   | 1 | 0 | 1 | 0 | 1 |
| -   | - | - | - | - | - | 
| pre | 0 | 1 | 1 | 1 | 1 | 
| cur | 1 | 1 | 1 | 1 | 1 | 
| n   | 0 | 1 | 2 | 3 | 4 | 

#### 代码

```javascript
/**
 * @param {string} s
 * @return {number}
 */
let countBinarySubstrings = function (s) {
    //current当前字符个数，默认为1，preview前一个字符个数，默认为0
  let current = 1, preview = 0, n = 0
  for (let i = 0, len = s.length; i < len - 1; i++) {
    if (s[i] === s[i + 1]) {
      current++
    } else {
      preview = current
      current = 1
    }
    if (preview >= current) n++
  }
  return n
}
```

#### 结果

Accepted

90/90 cases passed (76 ms)

Your runtime beats 99.68 % of javascript submissions

Your memory usage beats 55.2 % of javascript submissions (38.3 MB)

#### 复杂度分析：

- 时间复杂度：O(n)，

只需要遍历一遍s字符串，所以时间复杂度是O(n)

- 空间复杂度：O(1)。


<!--[Blog](https://blog.lailailee.com/2019/09/20/2019-09-20-%E7%AE%97%E6%B3%95-[1]%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/)-->